{"body":"# Zippers for Common Lisp\r\n\r\n## Supported Implementations\r\n\r\nThe code was tested and runs successfuly on each of the following\r\nCommon Lisp platforms:\r\n\r\n* [Clozure CL](http://ccl.clozure.com/)\r\n* [SBCL](http://www.sbcl.org/)\r\n* [CLISP](http://www.gnu.org/software/clisp/)\r\n\r\n## Runtime Dependencies\r\n\r\nFirst, make sure that you have\r\n[ASDF](http://common-lisp.net/project/asdf/) installed and loaded:\r\n\r\n````common-lisp\r\n> (asdf:asdf-version)\r\n\"2.017\"\r\n````\r\n\r\nA simple way to get ASDF is via\r\n[QuickLisp](http://www.quicklisp.org/beta/), which is a library\r\nmanager for Common Lisp.\r\n\r\n## Installing cl-zipper\r\n\r\nAt this moment the package is not yet available for download through\r\nQuickLisp.\r\n\r\nHowever, it could be installed rather easily by cloning the project\r\ninside `~/quicklisp/local-projects` directory and running\r\n`(ql:quickload :cl-zipper)` in the REPL.\r\n\r\n## Getting Started\r\n\r\nFirst, start a REPL and load the system:\r\n\r\n````common-lisp\r\n(asdf:load-system :cl-zipper)\r\n(use-package :cl-zipper)\r\n````\r\n\r\nSuppose we have the tree `(a + b) * (c - d)` to play with:\r\n\r\n````common-lisp\r\n(defparameter *loc* (zipper '(* (+ a b) (- c d))))\r\n````\r\n\r\n### Navigation Primitives\r\n\r\nNow, let's examine the four basic zipper operations: `(go-down loc)`,\r\n`(go-right loc)`, `(go-left loc)`, and `(go-up loc)`.\r\n\r\nEvery zipper operation gets what we call a _loc_, or location, which\r\nconsists in the current focus of attention within the tree, and the\r\nreturn value is a _loc_ that represents the new location after such\r\noperation is performed.\r\n\r\nFor instance, let's take a look at what `(go-down loc)` does:\r\n\r\n````common-lisp\r\n> (documentation 'go-down 'function)\r\n\"Returns the loc of the leftmost child of the node at this loc, or\r\nnil if no children.\"\r\n````\r\n\r\nObtaining more information about the current _loc_ and its\r\nsurroundings:\r\n\r\n````common-lisp\r\n(defparameter *loc-down* (go-down *loc*))\r\n\r\n(car *loc-down*)    ;; *\r\n(lefts *loc-down*)  ;; NIL\r\n(rights *loc-down*) ;; ((+ A B) (- C D))\r\n````\r\n\r\nThe nice thing about this kind of abstraction is that you can navigate\r\na tree by chaining calls:\r\n\r\n````common-lisp\r\n(defparameter *loc-down-right* (go-right *loc-down*))\r\n\r\n(car *loc-down-right*)    ;; (+ A B)\r\n(lefts *loc-down-right*)  ;; (*)\r\n(rights *loc-down-right*) ;; ((- C D))\r\n````\r\n\r\nBy now you probably have guessed what the other basic navigation\r\nprimitives do:\r\n\r\n````common-lisp\r\n> (documentation 'go-left 'function)\r\n\"Returns the loc of the left sibling of the node at this loc,\r\nor nil.\"\r\n````\r\n\r\nTo zip up to the parent node of a nested _loc_:\r\n\r\n````common-lisp\r\n(car (go-up *loc-down-right*)) ;; (* (+ A B) (- C D))\r\n````\r\n\r\n### Navigation Shortcuts\r\n\r\nUse `(go-next loc)` if you just want to visit the nodes of\r\nthe tree in depth-first order:\r\n\r\n````common-lisp\r\n(defparameter *loc-next-2* (go-next (go-next *loc*)))\r\n\r\n(car *loc-next-2*)    ;; (+ A B)\r\n(lefts *loc-next-2*)  ;; (*)\r\n(rights *loc-next-2*) ;; (- C D)\r\n````\r\n\r\nSimilarly, use `(go-prev loc)` to walk to the opposite direction:\r\n\r\n````common-lisp\r\n(defparameter *loc-next* (go-prev *loc-next-2*))\r\n\r\n(car *loc-next*)    ;; *\r\n(lefts *loc-next*)  ;; NIL\r\n(rights *loc-next*) ;; ((+ A B) (- C D))\r\n````\r\n\r\nNow, suppose you have a _loc_ that points to `A`:\r\n\r\n````common-lisp\r\n(defparameter *loc-a* (go-right (go-down (go-right (go-down *loc*)))))\r\n\r\n(car *loc-a*)    ;; A\r\n(lefts *loc-a*)  ;; (+)\r\n(rights *loc-a*) ;; (B)\r\n`````\r\n\r\nYou can get the leftmost or rightmost _loc_ with a simple function\r\ncall:\r\n\r\n````common-lisp\r\n(car (leftmost *loc-a*))  ;; +\r\n(car (rightmost *loc-a*)) ;; B\r\n````\r\n\r\n### Removing Nodes\r\n\r\nJust call `(remove-node loc)` to remove the node at _loc_:\r\n\r\n````common-lisp\r\n(root-node (remove-node *loc-a*)) ;; (* (+ B) (- C D))\r\n````\r\n\r\n### Inserting Nodes\r\n\r\nThe first functions we'll see are `(insert-left loc node)` and\r\n`(insert-right loc node)`:\r\n\r\n````common-lisp\r\n(root-node (insert-left *loc-a* 'x))  ;; (* (+ X A B) (- C D))\r\n(root-node (insert-right *loc-a* 'x)) ;; (* (+ A X B) (- C D))\r\n````\r\n\r\nIf the node at _loc_ is the root of a subtree, it's possible to\r\ninsert child nodes with `(append-down loc node)` and\r\n`(insert-down loc node)`.\r\n\r\nThe `(append-down loc node)` function inserts a node as the rightmost\r\nchild of the node at _loc_:\r\n\r\n````common-lisp\r\n(defparameter *loc-subtree* (go-right (go-down *loc*)))\r\n(root-node (append-down *loc-subtree* '(/ x y))) ;; (* (+ A B (/ X Y)) (- C D))\r\n````\r\n\r\nUse `(insert-down loc node)` to insert a node as the leftmost child:\r\n\r\n````common-lisp\r\n(root-node (insert-down *loc-subtree* '(/ x y))) ;; (* ((/ X Y) + A B) (- C D))\r\n````\r\n\r\n### Changing Nodes\r\n\r\nUse `(change-node loc node)` in order to replace the node at _loc_:\r\n\r\n````common-lisp\r\n(root-node (change-node *loc-a* 'x)) ;; (* (+ X B) (- C D))\r\n````\r\n\r\nIf the change is modeled by a function, the function\r\n`(edit-node loc func &rest args)` replaces the node at _loc_ with the\r\nresult of applying `(func (car loc) arg1 arg2 ... argN)`:\r\n\r\n````common-lisp\r\n(defun crazy-fn (node n1 n2)\r\n  (if (equal node 'A)\r\n    n1\r\n    n2))\r\n\r\n(root-node (edit-node *loc-a* #'crazy-fn 1 2)) ;; (* (+ 1 B) (- C D))\r\n````\r\n\r\n### Zippers Are Functional\r\n\r\nWith zippers you can write code that looks like an imperative,\r\ndestructive walk through a tree, call `(root-node loc)` when you are\r\ndone and get a new tree reflecting all the changes, when in fact nothing\r\nat all is mutated - it's all thread safe and shareable.\r\n\r\n## Contributing\r\n\r\nIf you found bugs or want to add new features to cl-zipper, the first\r\nstep is to write tests that cover your changes.\r\n\r\nAs you'll see in a moment, [5am](http://www.cliki.net/FIVEAM) testing\r\nframework is required in order to run the tests.\r\n\r\nNow, clone this repository and open Lisp REPL at its root directory:\r\n\r\n````common-lisp\r\n> (ql:quickload :fiveam)\r\n...\r\n(:FIVEAM)\r\n\r\n> (asdf:test-system :cl-zipper)\r\n...\r\nT\r\n````\r\n\r\n## License\r\n\r\nCopyright (C) Daniel Fernandes Martins\r\n\r\nDistributed under the New BSD License. See COPYING for further details.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Common Lisp implementation of the Zipper data structure first described by Ger√°rd Huet.","name":"cl-zipper"}